# -*- coding: utf-8 -*-
"""DSA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HS6_YgPsRpTTzLZldc6uKZeG8Tbb-6-v

# ***CREATE OWN LIST***
"""

class Meralist:
    def __init__(self):
        self.size=1
        self.n =0
        self.A =self.makeArray(self.size)

    def makeArray(self,capacity):
        return(capacity*ctypes.py_object)()

    def __len__(self):
        return self.n

    def append(self,item):
        if self.n==self.size:
            self.resize(self.size*2)

        self.A[self.n] = item
        self.n=self.n+1

    def resize(self,new_capacity):
        self.B= self.makeArray(new_capacity)
        self.size = new_capacity
        for i in range(self.n):
            self.B[i] = self.A[i]

        self.A= self.B

    def __getitem__(self,index):
        if 0<= index<self.n:
            return (self.A[index])

        else:
            return "indexing error"

    def pop(self):
        if self.n ==0 :
            return "empty"
        else:
            print(self.A[self.n-1])
            self.n=self.n-1

    def clear(self):
        self.n=0
        self.size=1

    def find(self, item):
        print(self.n)
        for i in range(self.n+1):
            if self.A[i] == item:
                return i
            else:
                return "value error"

    def insert(self,pos,item):
        if self.n== self.size:
            self.resize(self.size*2)
        for i in range (self.n,pos,-1):
            self.A[i] = self.A[i-1]
        self.A[pos] =item
        self.n=self.n+1

    def delete(self,pos):
        for i in range(pos,self.n-1):
            self.A[i]=self.A[i+1]

        self.n=self.n-1

    def sort(self):
        for i in range(self.n):
            for j in range(self.n):
                if self.A[j] > self.A[i]:
                    temp= self.A[i]
                    self.A[i]=self.A[j]
                    self.A[j]=temp


    def max(self):
            self.sort()
            print(self.A[self.n - 1])

    def min(self):
            self.sort()
            print(self.A[0])

    def sum(self):
        s=0
        for i in range(self.n):
            s=s+self.A[i]
        print(s)

    def __str__(self):
        result= ""
        for i in range(self.n):
            result=result+str(self.A[i])+","

        return "["+result[:-1]+"]"

"""# **LINKED LIST***"""

class Node:
    def __init__(self,value):
        self.data=value
        self.next=None

class LinkedList:
    def __init__(self):
#         initially assigning head equal to none
        self.head=None
#         to count the number of node
        self.n=0

    def __len__(self):
        return self.n

    def insert_head(self,value):

#   new node
            new_node=Node(value)
#     connection
            new_node.next=self.head
            self.head=new_node

            self.n=self.n+1

    def __str__(self):
        curr=self.head
        result=""
        while curr!= None:
            result= result+str(curr.data)+"-->"
            curr= curr.next

        return result[:-3]

    def append(self,value):
        new_node=Node(value)

        if self.head==None:
            self.head=new_node
            self.n=self.n+1
        curr=self.head

        while curr.next!=None:
            curr=curr.next
#          at the end of the node
        curr.next =new_node
        self.n=self.n+1

    def insert_after(self,after,value):
        new_node=Node(value)
        curr=self.head
        while curr!=None:
            if curr.data==after:
                break
            curr=curr.next

        if curr!=None:
            new_node.next=curr.next
            curr.next=new_node
            self.n=self.n+1
        else:
            return "Item not found:"

    def clear(self):
        self.head=None
        self.n=0

    def delete_head(self):
        if self.head== None:
            return "empty list "

        self.head=self.head.next
        self.n =self.n-1

    def delete_tail(self):

        if self.head == None:
                  # empty
                return 'Empty LL'

        curr = self.head

                # kya linked list me 1 item hai?
        if curr.next == None:
                  # head hi hoga(delete from head)
                  return self.delete_head()


        while curr.next.next != None:
                     curr = curr.next

                # curr -> 2nd last node
        curr.next = None
        self.n = self.n - 1

    def delete_after(self,value):
        curr=self.head
        if self.head == None:
          return "empty LL"
        while curr.next !=None:
            if curr.next.data == value:
                break

        curr=curr.next
        if curr.next == None:
          return "Item not found"

        curr.next=curr.next.next

    def search(self,value):
      curr = self.head
      pos=0

      while curr!= None:
        if curr.data == value:
          return pos
        pos =pos+1
        curr=curr.next
      return "number not in list"

    def __getitem__(self,index):
        curr=self.head
        pos=0
        if self.head == None:
            return "empty list"
        while curr!=None:
            if pos == index:
                return curr.data
            pos=pos+1
            curr=curr.next
        return "index not found"

L=LinkedList()

L.insert_head(1)
L.insert_head(2)
L.insert_head(3)
L.insert_head(4)

len(L)

print(L)

L[6]

L.search(4)

"""# **CREATE STACK USING LINKED LIST**

"""

class node:
    def __init__(self,value) :
         self.next= None
         self.data=value

from re import T
class Stack:
    def __init__(self) :
        self.head = None

    def isempty(self):
        return self.head==None


    def push(self,value):
        new_node=node(value)

        new_node.next=self.head
        self.head=new_node

    def traverse(self):

        curr=self.head

        while curr!=None:
            print(curr.data)
            curr= curr.next

    def peak(self):
        return self.head.data

    def pop(self):
        curr =self.head
        if self.head == None:
            return "empty stack"
        else:
            data = self.head.data
            self.head=self.head.next
            return data

    def size(self):
        curr =self.head
        counter=0
        while curr!=None:
            counter=counter+1
            curr=curr.next
        return counter

s=Stack()

s.push(4)
s.push(2)
s.push(1)
s.push(5)

s.traverse()

s.size()

"""# QUESTIONS ON STACK

1.   STRING REVERSAL
"""

def reverse_string(text):
    s=Stack()
    for i in text:
        s.push(i)

    result=""

    while (not s.isempty()):
        result=result+s.pop()

    print(result)

reverse_string("hello")

"""2.   String Editor


"""

def stringEditor(text,pattern):
    u=Stack()
    r=Stack()

    for i in text:
        u.push(i)
    for i in pattern:
        if i=="u":
            data=u.pop()
            r.push(data)
        elif i =="r":
            data=r.pop()
            u.push(data)

    res=""

    while(not u.isempty()):
        res=u.pop()+ res

    print(res)

stringEditor("kolkata","uuur")

"""

3.  celebrity poblem


"""

L = [
     [0,0,1,1],
     [0,0,1,0],
     [0,0,0,0],
     [0,0,1,0]
]

def celibrity(L):
    s=Stack()

    for i in range(len(L)):
        s.push(i)

    while s.size()>=2:
        i=s.pop()
        j=s.pop()
        if L[i][j]==0:
            s.push(i)
        else:
            s.push(j)
    celeb=s.pop()
    for i in range(len(L)):
        if i!=celeb:
            if L[i][celeb]!=1 or L[celeb][i]!=0:
                print("no one is celebrity")
                return
    print("the celebrity is",celeb)

celibrity(L)

"""# CREATE QUEUE"""

class node:
    def __init__(self,value):
        self.data=value
        self.next=None

class Queue:
    def __init__(self):
        self.head= None
        self.tail = None

    def enque(self,value):
        new_node=node(value)
        if self.tail== None and self.head==None:
            self.head = new_node
            self.tail=new_node
        else:
            self.tail.next=new_node
            self.tail=new_node

    def deque(self):
        if self.head == None:
            return "Empty queue"
        else:
            self.head=self.head.next

    def traverse(self):
        curr=self.head

        if self.head==None:
            return "Empty "
        while curr!= None:
            print(curr.data,end=" ")
            curr=curr.next

    def isempty(self):
        return self.head==None

    def front_item(self):
        if self.head == None:
            return "empty"
        return self.head.data

    def rear_item(self):
        if self.head==None:
            return "Empty "
        return self.tail.data

q=Queue()

q.enque(4)
q.enque(3)
q.enque(2)
q.enque(1)

q.traverse()

q.deque()

q.isempty()

q.front_item()

"""# HASHING"""

class dict:
    def __init__(self,size):
        self.size=size
        self.slot=[None]*self.size
        self.data=[None]*self.size

    def hash_func(self,key):
        return abs(hash(key))%self.size

    def rehash(self,old_hash):
        return (old_hash+1)%self.size

    def put(self,key,value):
        hash = self.hash_func(key)

        if  self.slot[hash]== None:
            self.slot[hash] = key
            self.data[hash]= value

        else:
            if self.slot[hash]==key:
                self.data[hash] =value
            else:
                new_hash = self.rehash(hash)

                while self.slot[new_hash]!=None and self.slot[new_hash]!= key:
                    new_hash= self.rehash(new_hash)

                if self.slot[new_hash]==None:
                    self.slot[new_hash]=key
                    self.data[new_hash]=value
                else:
                    self.slot[new_hash]= value

    def __setitem__(self,key,value):
        self.put(key,value)

    def get(self,key):
        startpos = self.hash_func(key)
        currentpos = startpos

        while self.slot[currentpos]!=None:
            if self.slot[currentpos] == key:
                return self.data[currentpos]

            currentpos=self.rehash(currentpos)

            if currentpos == startpos:
                return "not found"

        return "not found"

    def __getitem__(self,key):
        return self.get(key)

d=dict(3)

print(d.slot)
print(d.data)

d.put("php",70)

abs(hash("php"))%3

d["python"]=69
d["java"]=70
d["php"]=71

d.get("python")

d.get("c")

"""# BINARY SEARCH TREE"""

class BST:
    def __init__(self,key):
        self.data= key
        self.left_child=None
        self.right_child=None

    def insert(self,key):
        if  self.data is None:
            self.data=key
            return
        if self.data> key:
            if self.left_child:
                self.left_child.insert(key)
            else:
                self.left_child = BST(key)
        else:
             if self.right_child:
                self.right_child.insert(key)
             else:
                self.right_child = BST(key)

    def search(self,key):
        if self.data==key:
            print("Data is present")
            return
        if key< self.data:
            if self.left_child:
                self.left_child.search(key)
            else:
                print("Data is not present")
        else:
            if key> self.data:
                if self.right_child:
                    self.right_child.search(key)
            else:
                print("Data is not present")

    def preorder(self):
        print(self.data)
        if self.left_child:
            self.left_child.preorder()
        if self.right_child:
            self.right_child.preorder()

    def  inorder(self):
        if self.left_child:
            self.left_child.inorder()
        print(self.data)

        if self.right_child:
            self.right_child.inorder()

    def postorder(self):
        if self.left_child:
            self.left_child.postorder()
        if self.right_child:
            self.right_child.postorder()
        print(self.data)

    def delete(self,key):
        if self.data is None:
            print("empty")
            return
        if  key < self.data:
            if self.left_child:
                self.left_child=self.left_child.delete(key)
            else:
                print("Data not found")
        if self.data < key:
            if self.right_child:
                self.right_child=self.right_child.delete(key)
            else:
                print("Data not found")
        else:
            if self.left_child is None:
                temp = self.right_child
                self = None
                return temp

            if self.right_child is None:
                temp = self.left_child
                self = None
                return temp

            node = self.right_child
            while node.left_child:
                node = node.left_child

            self.data = node.data
            self.right_child= self.right_child.delete(node.delete)

        return self

    def min(self):
        current =  self
        while  current.left_child:
            current = current.left_child

        print(current.data)

    def max(self):
        current =  self
        while  current.right_child:
            current = current.right_child

        print(current.data)

root=BST(10)
list1=[6,3,1,98,7]
for i in list1:
    root.insert(i)
root.search(3)
print("preorder")
root.preorder()
print("inorder")
root.inorder()
print("postorder")
root.postorder()
print("deletion:")
root.delete(98)
print("minimum number")
root.min()
print("maximum number")
root.max()

root.inorder()

n=10
j=0
a=""
t=0
p=""
c="1010"
for j in range(n):
    print(j)
    if j==0:
       a=(len(c)-len(str(j)))*"0"+str(j)
    else:
        while j > 0:
            print("Now")
            t = j % 2
            j = j // 2
            a = a + str(t)
    p=(len(c)-len(a))*"0"+a[::-1]
    print(p)
    a=""

print(1%2)

n=int(input())
x=n
first=[]
for i in range(n+1):
    first.append(n+i)
print(first)
s=""
r=0
c=""
while n>0:
    r=n%2
    n=n//2
    s=s+str(r)
# print(s[::-1])
c=s[::-1]
print(c)
a=""
t=0
p=""
l1=[]
for j in range(x):
    if j==0:
       a=(len(c)-len(str(j)))*"0"+str(j)
    else:
        while j > 0:
            t = j % 2
            j = j // 2
            a = a + str(t)
    p=(len(c)-len(a))*"0"+a[::-1]
    print(p)
    l1.append(p)
    a=""
print(l1)
l2=[]
l3=""
la=[]
for i in range(len(l1)):
    l2.append(l1[i])